"use strict";(self.webpackChunknodegui=self.webpackChunknodegui||[]).push([[8040],{8753:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>c,contentTitle:()=>r,default:()=>l,frontMatter:()=>s,metadata:()=>a,toc:()=>d});var o=n(74848),i=n(28453);const s={sidebar_label:"Understanding Memory",title:"Understanding Memory"},r=void 0,a={id:"guides/understanding-memory",title:"Understanding Memory",description:"NodeGui allows you to use a library designed for C++ (Qt) from the JavaScript language. C++ and JavaScript have very different approaches for managing the memory of objects. C++ expects the programmer to manually create objects and later destroy them to free up their memory. It is the job of the programmer to destroy objects at the right time and when it is safe. JavaScript uses a Garbage Collector which detects when an object is longer being used and then automatically destroys it, freeing up its memory. Most of the time NodeGui can coordinate these two systems in a way which is mostly transparent to the JavaScript developer. However, there are situations where it is necessary to have some understanding of what is happening being in the scenes.",source:"@site/docs/guides/understanding-memory.md",sourceDirName:"guides",slug:"/guides/understanding-memory",permalink:"/docs/guides/understanding-memory",draft:!1,unlisted:!1,editUrl:"https://github.com/nodegui/nodegui/edit/master/website/docs/guides/understanding-memory.md",tags:[],version:"current",frontMatter:{sidebar_label:"Understanding Memory",title:"Understanding Memory"},sidebar:"guides",previous:{title:"Debugging in VSCode",permalink:"/docs/guides/debugging-in-vscode"},next:{title:"Advanced QEvent Handling",permalink:"/docs/guides/advanced-qevent-handling"}},c={},d=[{value:"Qt&#39;s QObject Memory Management",id:"qts-qobject-memory-management",level:2},{value:"JavaScript Wrappers",id:"javascript-wrappers",level:2},{value:"QObject End of Life",id:"qobject-end-of-life",level:2},{value:"Problems with Unexpected Object Destruction",id:"problems-with-unexpected-object-destruction",level:2},{value:"Debugging",id:"debugging",level:2}];function h(e){const t={code:"code",em:"em",h2:"h2",li:"li",p:"p",pre:"pre",ul:"ul",...(0,i.R)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(t.p,{children:"NodeGui allows you to use a library designed for C++ (Qt) from the JavaScript language. C++ and JavaScript have very different approaches for managing the memory of objects. C++ expects the programmer to manually create objects and later destroy them to free up their memory. It is the job of the programmer to destroy objects at the right time and when it is safe. JavaScript uses a Garbage Collector which detects when an object is longer being used and then automatically destroys it, freeing up its memory. Most of the time NodeGui can coordinate these two systems in a way which is mostly transparent to the JavaScript developer. However, there are situations where it is necessary to have some understanding of what is happening being in the scenes."}),"\n",(0,o.jsx)(t.h2,{id:"qts-qobject-memory-management",children:"Qt's QObject Memory Management"}),"\n",(0,o.jsxs)(t.p,{children:["Much of Qt is based around the ",(0,o.jsx)(t.code,{children:"QObject"})," class. It is the base class of many Qt classes including most of the widgets exposed by NodeGui. ",(0,o.jsx)(t.code,{children:"QObject"})," provides many useful features on top of C++ for working with objects. It has support for easier memory management. This system is built around the idea of object ownership and trees of objects which can be freed as a group. Each ",(0,o.jsx)(t.code,{children:"QObject"})," can participate in a tree of objects. Each ",(0,o.jsx)(t.code,{children:"QObject"})," has a list of child objects, and may also have a parent ",(0,o.jsx)(t.code,{children:"QObject"}),". When a ",(0,o.jsx)(t.code,{children:"QObject"})," is destroyed, all of its attached child objects are destroyed with it."]}),"\n",(0,o.jsxs)(t.p,{children:["Trees of objects is a good model for user interfaces which are also structured in hierarchies. Qt's widgets are built on top of ",(0,o.jsx)(t.code,{children:"QObject"})," and its object trees. The same object tree is used by widgets for memory management and UI layout / structuring."]}),"\n",(0,o.jsxs)(t.p,{children:[(0,o.jsx)(t.code,{children:"QObject"})," contains a number of methods for examining this tree of objects:"]}),"\n",(0,o.jsxs)(t.ul,{children:["\n",(0,o.jsxs)(t.li,{children:[(0,o.jsx)(t.code,{children:"parent()"})," - Get the parent of an object, or ",(0,o.jsx)(t.code,{children:"null"}),"."]}),"\n",(0,o.jsxs)(t.li,{children:[(0,o.jsx)(t.code,{children:"setParent()"})," - Set the parent of an object."]}),"\n",(0,o.jsxs)(t.li,{children:[(0,o.jsx)(t.code,{children:"children()"})," - Get a list of the child objects belonging to this object."]}),"\n"]}),"\n",(0,o.jsx)(t.h2,{id:"javascript-wrappers",children:"JavaScript Wrappers"}),"\n",(0,o.jsx)(t.p,{children:'Node runs on the V8 JavaScript engine. It can\'t directly work with C++ object like those from Qt. To bridge the gap between V8 and Qt, NodeGui creates "wrapper" C++ and JavaScript objects which can translate between the two worlds. A JavaScript object "wrapper" will wrap a corresponding Qt object in C++. As a JavaScript developer you don\'t have to pay much attention to this. It happens automatically in the background.'}),"\n",(0,o.jsx)(t.h2,{id:"qobject-end-of-life",children:"QObject End of Life"}),"\n",(0,o.jsxs)(t.p,{children:["There are two ways in which a ",(0,o.jsx)(t.code,{children:"QObject"})," can be destroyed, starting from either the C++ side or JavaScript side."]}),"\n",(0,o.jsxs)(t.p,{children:["The JavaScript side is the most common. If the Garbage Collector discovers that a wrapper is no longer being referenced, then it will destroy the wrapper. When the C++ side of the wrapper is destroyed, it will also destroy its corresponding Qt object ",(0,o.jsx)(t.em,{children:"if that object is not part of an object tree"}),". In other words, if the ",(0,o.jsx)(t.code,{children:"QObject"})," has a parent object set, then it will not be destroyed and NodeGui assumes that the responsibility for destroying and cleaning up that object belongs to the parent object and the Qt ",(0,o.jsx)(t.code,{children:"QObject"})," memory system."]}),"\n",(0,o.jsxs)(t.p,{children:["When a ",(0,o.jsx)(t.code,{children:"QObject"})," is destroyed from the C++ side, then NodeGui detects this and sets the reference to the object itside the JavaScript wrapper object, to ",(0,o.jsx)(t.code,{children:"null"}),". If any attempt is made to use the JS wrapper object, then it will hit the ",(0,o.jsx)(t.code,{children:"null"})," and throw an exception."]}),"\n",(0,o.jsx)(t.h2,{id:"problems-with-unexpected-object-destruction",children:"Problems with Unexpected Object Destruction"}),"\n",(0,o.jsxs)(t.p,{children:["A NodeGui object suddenly throws an exception regarding a ",(0,o.jsx)(t.code,{children:"null"})," if you try to use a method on it.  This situation can happen if underlying C++ Qt object is destroyed and afterwards you still try to use it via its wrapper."]}),"\n",(0,o.jsxs)(t.p,{children:["The most common way this can happen is if a ",(0,o.jsx)(t.code,{children:"QObject"})," is part of an object tree and one of its parent objects is destroyed which then also destroys the rest of the tree. If you don't want an object to be destroyed with its parent object, then you need to remove it from the tree before the parent is destroyed. Calling ",(0,o.jsx)(t.code,{children:"setParent(null)"})," on the object is enough to disconnect it from its parent."]}),"\n",(0,o.jsx)(t.h2,{id:"debugging",children:"Debugging"}),"\n",(0,o.jsx)(t.p,{children:"NodeGui provides some tools to help track the lifecycle of objects and figure out why your application isn't running the way you expect."}),"\n",(0,o.jsxs)(t.p,{children:["Each ",(0,o.jsx)(t.code,{children:"QObject"})," instance, and subclass also, has an ID to identify it. The method ",(0,o.jsx)(t.code,{children:"QObject._id()"})," can be used to fetch the ID for an object. The ID is valid for the lifetime of the object, although it could be reused once this object is destroyed."]}),"\n",(0,o.jsx)(t.p,{children:"NodeGui manages the lifecycle of objects and it is possible to turn on logging regarding the creation and destruction of objects. The following functions take a boolean to turn this logging on or off:"}),"\n",(0,o.jsxs)(t.ul,{children:["\n",(0,o.jsxs)(t.li,{children:[(0,o.jsx)(t.code,{children:"setLogDestroyQObject()"})," - Turn logging of object destruction on/off."]}),"\n",(0,o.jsxs)(t.li,{children:[(0,o.jsx)(t.code,{children:"setLogCreateQObject()"})," - Turn logging of object creation on/off."]}),"\n"]}),"\n",(0,o.jsxs)(t.p,{children:["These log messages contain the ID of the object as returned from ",(0,o.jsx)(t.code,{children:"QObject._id()"}),"."]}),"\n",(0,o.jsx)(t.p,{children:"A typical usage of this logging would be to narrow down the exact place where an object is being unexpectedly destroyed:"}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-js",children:"const { setLogDestroyQObject, setLogCreateQObject } = require('@nodegui/nodegui');\n\nsetLogCreateQObject(true);\nsetLogDestroyQObject(true);\n\nconst myWidget = new QWidget();\nconsole.log(`myWidget has ID: ${myWidget._id()}.`);\n\n// ...\n// ... Code which somehow triggers the destruction of myWidget.\n// ...\nconsole.log(`Reached crash point.`);\nconst size = myWidget.size();\n// ^ line which triggers an exception because the object is destroyed.\n"})}),"\n",(0,o.jsx)(t.p,{children:"The logging output from the application might be:"}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{children:"NodeGui: Created C++ object with ID: 17533348349032.\nmyWidget has ID: 17533348349032.\nNodeGui: Destroyed C++ object with ID: 17533348349032.\nReached crash point.\nUncaught TypeError: Cannot read property 'size' of null\n"})}),"\n",(0,o.jsx)(t.p,{children:"More logging could be added to narrow down which section of code triggers the destruction of the object."})]})}function l(e={}){const{wrapper:t}={...(0,i.R)(),...e.components};return t?(0,o.jsx)(t,{...e,children:(0,o.jsx)(h,{...e})}):h(e)}},28453:(e,t,n)=>{n.d(t,{R:()=>r,x:()=>a});var o=n(96540);const i={},s=o.createContext(i);function r(e){const t=o.useContext(s);return o.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function a(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:r(e.components),o.createElement(s.Provider,{value:t},e.children)}}}]);