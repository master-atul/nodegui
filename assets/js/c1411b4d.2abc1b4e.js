"use strict";(self.webpackChunknodegui=self.webpackChunknodegui||[]).push([[6003],{98898:(e,t,a)=>{a.r(t),a.d(t,{assets:()=>o,contentTitle:()=>c,default:()=>d,frontMatter:()=>s,metadata:()=>i,toc:()=>p});var n=a(74848),r=a(28453);const s={},c="Wrapper caching and memory management",i={id:"development/wrapper_caching",title:"Wrapper caching and memory management",description:'"Wrapper Keep Alive" case',source:"@site/docs/development/wrapper_caching.md",sourceDirName:"development",slug:"/development/wrapper_caching",permalink:"/docs/development/wrapper_caching",draft:!1,unlisted:!1,editUrl:"https://github.com/nodegui/nodegui/edit/master/website/docs/development/wrapper_caching.md",tags:[],version:"current",frontMatter:{}},o={},p=[{value:"&quot;Wrapper Keep Alive&quot; case",id:"wrapper-keep-alive-case",level:2},{value:"&quot;Wrapper Recycle&quot; case",id:"wrapper-recycle-case",level:2}];function h(e){const t={code:"code",h1:"h1",h2:"h2",header:"header",img:"img",p:"p",strong:"strong",...(0,r.R)(),...e.components};return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsx)(t.header,{children:(0,n.jsx)(t.h1,{id:"wrapper-caching-and-memory-management",children:"Wrapper caching and memory management"})}),"\n",(0,n.jsx)(t.h2,{id:"wrapper-keep-alive-case",children:'"Wrapper Keep Alive" case'}),"\n",(0,n.jsxs)(t.p,{children:['The goal of the "Wrapper Keep Alive" case is to maintain and "keep alive" wrappers for the life-time of a ',(0,n.jsx)(t.code,{children:"QObject"})," whose life-cycle is under complete control by Qt itself. i.e. Qt may expose the object, but it creates the instance itself and also destroys it later on. This situation applies to ",(0,n.jsx)(t.code,{children:"QScreen"})," and ",(0,n.jsx)(t.code,{children:"QClipboard"})," for example. A common use case for keeping a wrapper alive is to receive and relay signals from a ",(0,n.jsx)(t.code,{children:"QObject"})," back to JS during the object's life-time."]}),"\n",(0,n.jsx)(t.p,{children:(0,n.jsx)(t.img,{alt:"Wrapper cache diagram",src:a(75733).A+""})}),"\n",(0,n.jsx)(t.p,{children:'The WrapperCache (C++) holds strong JS references to the Napi wrapper instances. This keeps them alive. When the core QObject is destroyed the "destroyed" signal is emitted and received by WrapperCache (C++). It then removes the Napi wrapper from its cache and uses a callback function to inform the WrapperCache (JS) about the destruction. WrapperCache (JS) can also perform clean up and null out references to the Napi wrappers. If someone then tries to use a JS side wrapper, then will get a JS side null pointer exception with stacktrace.'}),"\n",(0,n.jsx)(t.p,{children:(0,n.jsx)(t.strong,{children:"Life-cycle Sequence"})}),"\n",(0,n.jsxs)(t.p,{children:["This sequence diagram shows the events when the application calls ",(0,n.jsx)(t.code,{children:"QWindow.screen()"})," to fetch the ",(0,n.jsx)(t.code,{children:"QScreen"})," for the window. The ",(0,n.jsx)(t.code,{children:"QScreen"})," instance is fully created and managed by Qt. Here you can see how the wrapper creation interacts with the JS and C++ side cache classes. You can also see how the wrappers are gracefully shutdown when the core Qt object is destroyed. Any JS side use of the destroyed wrapper / Qt object results in a neat JS side null pointer exception. This is much better than null pointer segfault on the C++ side."]}),"\n",(0,n.jsx)(t.p,{children:(0,n.jsx)(t.img,{alt:"Wrapper keep alive sequence diagram",src:a(38633).A+"",width:"1262",height:"1171"})}),"\n",(0,n.jsx)(t.h2,{id:"wrapper-recycle-case",children:'"Wrapper Recycle" case'}),"\n",(0,n.jsxs)(t.p,{children:['A related use case is where we want to "recycle" wrappers and ensure that for a QObject we only have one coresponding JS wrapper active at the same time. For example, repeated calls to ',(0,n.jsx)(t.code,{children:"QObject.parent()"})," should return the same value/object."]}),"\n",(0,n.jsx)(t.p,{children:'Another goal of this use case is to ensure that the unexpected destruction of the underlying QObject is handled in a more graceful and helpful way than just segfaulting the whole application. This requires the tracking of the QObject via its "destroy" signal and using that to communicate back to JS what has happened.'}),"\n",(0,n.jsx)(t.p,{children:'The object creation sequence runs quite differently than in the "Wrapper Keep Alive" case because the application initiates the creation of the object and NodeGui then creates the different wrappers on the JS and C++ sides.'}),"\n",(0,n.jsx)(t.p,{children:(0,n.jsx)(t.img,{alt:"Wrapper recycle sequence diagram",src:a(77473).A+"",width:"878",height:"456"})}),"\n",(0,n.jsx)(t.p,{children:'The destruction sequence in the case of the C++ object being destroyed is basically the same as the "Wrapper Keep Alive" case.'})]})}function d(e={}){const{wrapper:t}={...(0,r.R)(),...e.components};return t?(0,n.jsx)(t,{...e,children:(0,n.jsx)(h,{...e})}):h(e)}},75733:(e,t,a)=>{a.d(t,{A:()=>n});const n=a.p+"assets/images/wrapper_cache.drawio-46451808d90ee4e514947480ab75f185.svg"},38633:(e,t,a)=>{a.d(t,{A:()=>n});const n=a.p+"assets/images/wrapper_keep_alive_seq-1b49fcf3124585ae8900b6d67037c76e.png"},77473:(e,t,a)=>{a.d(t,{A:()=>n});const n=a.p+"assets/images/wrapper_recycle_seq-fff36b6a9f35e317fc1f0a3fe2d31542.png"},28453:(e,t,a)=>{a.d(t,{R:()=>c,x:()=>i});var n=a(96540);const r={},s=n.createContext(r);function c(e){const t=n.useContext(s);return n.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function i(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:c(e.components),n.createElement(s.Provider,{value:t},e.children)}}}]);